{"version":3,"sources":["geometry/Vec.ts","draw/canvas.ts","geometry/Angle.ts","system/instructions.ts","system/fractal-tree.ts","geometry/Line.ts","geometry/Turtle.ts","components/App.tsx","interpreter.ts","system/l-system.ts","index.tsx"],"names":["Vec","constructor","x","y","this","add","other","subtract","drawLines","lines","context","forEach","line","from","convertCoordinates","to","lineWidth","beginPath","moveTo","lineTo","stroke","drawLine","point","canvas","width","height","Angle","degrees","Math","PI","radians","Instruction","rules","1","0","getInstructions","char","DrawLeaf","DrawLine","PushPosition","PushAngle","TurnLeft","PopPosition","PopAngle","TurnRight","Noop","Line","Turtle","angle","position","gotoAngle","gotoPosition","turnRight","turnLeft","moveForward","distance","positionChange","cos","sin","App","setAngle","useState","iterations","setIterations","canvasRef","useRef","htmlFor","id","type","min","max","value","onChange","event","Number","target","onClick","current","systemInstructions","output","turtle","startAngle","startPosition","angleStack","positionStack","currentPosition","instruction","originalAngle","leafLength","segmentLength","turnAngle","end1","push","end2","end3","nextPosition","previousAngle","pop","previousPosition","interpret","symbols","generator","index","next","i","goto","axiom","split","map","join","generate","console","log","flatMap","fractalTree","fromDegrees","getContext","clearRect","clear","ref","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f96b4bfa.chunk.js","sourcesContent":["export default class Vec {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(other: Vec): Vec {\n    return new Vec(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: Vec): Vec {\n    return new Vec(this.x - other.x, this.y - other.y);\n  }\n}\n","import Line from '../geometry/Line';\nimport Vec from '../geometry/Vec';\n\n/**\n * Completely clear the canvas.\n */\nexport function clear(context: CanvasRenderingContext2D): void {\n  context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n}\n\n/**\n * Draw a list of lines.\n */\nexport function drawLines(lines: Line[], context: CanvasRenderingContext2D): void {\n  lines.forEach((line) => drawLine(line, context));\n}\n\n/**\n * Draw a single line.\n */\nexport function drawLine(line: Line, context: CanvasRenderingContext2D): void {\n  const from = convertCoordinates(line.from, context);\n  const to = convertCoordinates(line.to, context);\n  context.lineWidth = 1;\n  context.beginPath();\n  context.moveTo(from.x, from.y);\n  context.lineTo(to.x, to.y);\n  context.stroke();\n}\n\n/**\n * Convert \"normal\" coordinates into the coordinate system used by the HTML canvas element.\n *\n * \"Normal\" coordinates are how we (I) usually think of a coordainte system:\n * - The origin is in the center\n * - The x axis increases to the right\n * - The y axis increases going up\n *\n * The HTML canvas element uses a different system, where\n * - The origin is in the upper left\n * - The x axis increases to the right (as it does in the \"normal\" one)\n * - The y axis  increases going down.\n */\nexport function convertCoordinates(point: Vec, context: CanvasRenderingContext2D): Vec {\n  return new Vec(\n    point.x + (context.canvas.width / 2),\n    -point.y + (context.canvas.height / 2),\n  );\n}\n","export default class Angle {\n  radians: number;\n\n  static fromDegrees(degrees: number) {\n    return new Angle(degrees * Math.PI / 180);\n  }\n\n  constructor(radians: number) {\n    this.radians = radians;\n  }\n\n  get degrees() {\n    return this.radians * 180 / Math.PI;\n  }\n\n  subtract(other: Angle) {\n    return new Angle(this.radians - other.radians);\n  }\n\n  add(other: Angle) {\n    return new Angle(this.radians + other.radians);\n  }\n}\n","/**\n * L-system drawing instructions.\n */\nexport enum Instruction {\n  DrawLeaf,\n  DrawLine,\n  Noop,\n  PopAngle,\n  PopPosition,\n  PushAngle,\n  PushPosition,\n  TurnLeft,\n  TurnRight,\n}\n","import { Instruction } from './instructions';\nimport { generate, goto } from './l-system';\n\nconst axiom = '0';\nconst rules = {\n  1: '11',\n  0: '1[0]0',\n};\n\n/**\n * Generate drawing instructions for a binary, fractal tree.\n */\nexport default function fractalTree(iterations: number): Instruction[] {\n  const system = generate(axiom, rules);\n  const symbols = goto(system, iterations);\n  console.log('fractal tree symbols:', symbols);\n  return symbols.split('').flatMap(getInstructions);\n}\n\nfunction getInstructions(char: string): Instruction[] {\n  switch (char) {\n    case '0':\n      return [Instruction.DrawLeaf];\n    case '1':\n      return [Instruction.DrawLine];\n    case '[':\n      return [Instruction.PushPosition, Instruction.PushAngle, Instruction.TurnLeft];\n    case ']':\n      return [Instruction.PopPosition, Instruction.PopAngle, Instruction.TurnRight];\n    default:\n      return [Instruction.Noop];\n  }\n}\n","import Vec from './Vec';\n\nexport default class Line {\n  from: Vec;\n  to: Vec;\n\n  constructor(from: Vec, to: Vec) {\n    this.from = from;\n    this.to = to;\n  }\n}\n","import Angle from './Angle';\nimport Vec from './Vec';\n\n/**\n * This \"turtle\" keeps track of its position on an infinite plane through a series of rotations and\n * movements.\n *\n * Unlike the HTML canvas element's coordinate system, the coordinate system here is more\n * \"standarcd\". The x axis increases to the right, and the y axis increases going up.\n *\n *   x\n *   ┃\n *   ┃\n * ↑ ┃\n *   ┃\n * 0 ┗━━━━━━━━━━━ y\n *   0    →\n *\n * As far as angles go, 0 degrees points straight to the right, and 90 degrees straight up.\n */\nexport default class Turtle {\n  angle: Angle;\n  position: Vec;\n\n  constructor(angle: Angle, position: Vec) {\n    this.angle = angle;\n    this.position = position;\n  }\n\n  gotoAngle(angle: Angle): Vec {\n    this.angle = angle;\n    return this.position;\n  }\n\n  gotoPosition(position: Vec): Vec {\n    this.position = position;\n    return position;\n  }\n\n  turnRight(angle: Angle): Vec {\n    this.angle = this.angle.subtract(angle);\n    return this.position;\n  }\n\n  turnLeft(angle: Angle): Vec {\n    this.angle = this.angle.add(angle);\n    return this.position;\n  }\n\n  moveForward(distance: number): Vec {\n    const positionChange = new Vec(\n      Math.cos(this.angle.radians) * distance,\n      Math.sin(this.angle.radians) * distance,\n    );\n    this.position = this.position.add(positionChange);\n    return this.position;\n  }\n}\n","import { useRef, useState } from 'react';\nimport { clear, drawLines } from '../draw/canvas';\nimport Angle from '../geometry/Angle';\nimport Vec from '../geometry/Vec';\nimport fractalTree from '../system/fractal-tree';\nimport interpret from '../interpreter';\n\nexport default function App() {\n  const [angle, setAngle] = useState(45);\n  const [iterations, setIterations] = useState(7);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  function handleClick() {\n    if (canvasRef.current) {\n      const instructions = fractalTree(iterations);\n      const lines = interpret(instructions, {\n        segmentLength: 2,\n        startAngle: Angle.fromDegrees(90),\n        startPosition: new Vec(0, -300),\n        turnAngle: Angle.fromDegrees(angle),\n      });\n      const context = canvasRef.current.getContext('2d')!;\n      clear(context);\n      drawLines(lines, context);\n    }\n  }\n\n  return (\n    <>\n      <header>\n        <div>\n          <label htmlFor=\"angle\">Angle</label>\n          <input id=\"angle\" type=\"range\" min=\"10\" max=\"60\" value={angle} onChange={(event) => setAngle(Number(event.target.value))} />\n          <span>{angle}</span>\n        </div>\n        <div>\n          <label htmlFor=\"iterations\">Iterations</label>\n          <input id=\"iterations\" type=\"range\" min=\"1\" max=\"20\" value={iterations} onChange={(event) => setIterations(Number(event.target.value))} />\n          <span>{iterations}</span>\n        </div>\n        <button onClick={handleClick}>Draw</button>\n      </header>\n      <main>\n        <canvas ref={canvasRef} height=\"600\" width=\"600\" />\n      </main>\n    </>\n  );\n}\n","import Angle from './geometry/Angle';\nimport Line from './geometry/Line';\nimport Turtle from './geometry/Turtle';\nimport Vec from './geometry/Vec';\nimport { Instruction } from './system/instructions';\n\ninterface Context {\n  segmentLength: number,\n  startAngle: Angle,\n  startPosition: Vec,\n  turnAngle: Angle,\n}\n\n/**\n * Covnert a sequence of instructions into corresponding lines we can draw to a canvas.\n *\n * These lines are in a different coordinate system than the HTML canvas element uses, and will\n * need to be converted before drawing.\n */\nexport default function interpret(systemInstructions: Instruction[], context: Context): Line[] {\n  const output: Line[] = [];\n  const turtle = new Turtle(context.startAngle, context.startPosition);\n  const angleStack: Angle[] = [];\n  const positionStack: Vec[] = [];\n  let currentPosition = context.startPosition;\n\n  // Convert an instruction into one or more lines. This is a state machine, since the instructions\n  // can be statefull.\n  for (let instruction of systemInstructions) {\n    switch (instruction) {\n      case Instruction.DrawLeaf: {\n        const originalAngle = turtle.angle;\n        const leafLength = context.segmentLength / 2;\n\n        // Line 1.\n        turtle.turnLeft(context.turnAngle);\n        const end1 = turtle.moveForward(leafLength);\n        output.push(new Line(currentPosition, end1));\n\n        // Line 2.\n        turtle.gotoAngle(originalAngle);\n        turtle.gotoPosition(currentPosition);\n        const end2 = turtle.moveForward(leafLength);\n        output.push(new Line(currentPosition, end2));\n\n        // Line 3.\n        turtle.gotoAngle(originalAngle);\n        turtle.gotoPosition(currentPosition);\n        turtle.turnRight(context.turnAngle);\n        const end3 = turtle.moveForward(leafLength);\n        output.push(new Line(currentPosition, end3));\n\n        // Restore original location.\n        turtle.gotoAngle(originalAngle);\n        turtle.gotoPosition(currentPosition);\n        break;\n      }\n      case Instruction.DrawLine: {\n        const nextPosition = turtle.moveForward(context.segmentLength);\n        const line = new Line(currentPosition, nextPosition);\n        output.push(line);\n        currentPosition = nextPosition;\n        break;\n      }\n      case Instruction.PopAngle: {\n        const previousAngle = angleStack.pop();\n        if (previousAngle) {\n          turtle.gotoAngle(previousAngle);\n        }\n        break;\n      }\n      case Instruction.PopPosition: {\n        const previousPosition = positionStack.pop();\n        if (previousPosition) {\n          currentPosition = previousPosition;\n          turtle.gotoPosition(previousPosition);\n        }\n        break;\n      }\n      case Instruction.PushAngle:\n        angleStack.push(turtle.angle);\n        break;\n      case Instruction.PushPosition:\n        positionStack.push(turtle.position);\n        break;\n      case Instruction.TurnLeft:\n        turtle.turnLeft(context.turnAngle);\n        break;\n      case Instruction.TurnRight:\n        turtle.turnRight(context.turnAngle);\n        break;\n      default:\n        // Noop\n    }\n  }\n\n  return output;\n}\n","interface Rules {\n  [predecessor: string]: string;\n}\n\n/**\n * Generator that yields successive iterations of an L-system.\n *\n * The `axiom` is the first iteration, and the `rules` translate the symbols of each iteration into\n * the next. Any characters not appearing in the rules will be carried over as-is to the next\n * iteration.\n *\n * @see https://en.wikipedia.org/wiki/L-system\n */\nexport function* generate(axiom: string, rules: Rules): Generator<string> {\n  let current = axiom;\n\n  while (true) {\n    const next = current\n      .split('')\n      .map((char) => rules[char] || char)\n      .join('');\n\n    yield next;\n\n    current = next;\n  }\n}\n\n/**\n * Get the nth value from a generator. Note that generators are stateful, and this does progress\n * the generator to the specified index.\n */\nexport function goto<T>(generator: Generator<T>, index: number): T {\n  let value = generator.next().value;\n\n  for (let i = 1; i <= index; i++) {\n    value = generator.next().value;\n  }\n\n  return value;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}