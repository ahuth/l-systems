{"version":3,"sources":["geometry/Vec.ts","draw/canvas.ts","geometry/Angle.ts","system/instructions.ts","system/fractal-tree.ts","geometry/Line.ts","geometry/Turtle.ts","components/App.tsx","interpreter.ts","system/l-system.ts","index.tsx"],"names":["Vec","constructor","x","y","this","add","other","subtract","convertCoordinates","point","context","canvas","width","height","Angle","degrees","Math","PI","radians","Instruction","rules","1","0","getInstructions","char","DrawLeaf","DrawLine","PushPosition","PushAngle","TurnLeft","PopPosition","PopAngle","TurnRight","Noop","Line","from","to","Turtle","angle","position","gotoAngle","gotoPosition","turnRight","turnLeft","moveForward","distance","positionChange","cos","sin","App","setAngle","useState","iterations","setIterations","length","setLength","canvasRef","useRef","htmlFor","id","type","min","max","value","onChange","event","Number","target","step","onClick","current","lines","systemInstructions","output","turtle","startAngle","startPosition","angleStack","positionStack","currentPosition","instruction","originalAngle","leafLength","segmentLength","turnAngle","end1","push","end2","end3","nextPosition","line","previousAngle","pop","previousPosition","interpret","symbols","generator","index","next","i","goto","axiom","split","map","join","generate","console","log","flatMap","fractalTree","fromDegrees","getContext","clearRect","clear","reduce","acc","then","Promise","resolve","lineWidth","beginPath","moveTo","lineTo","stroke","drawLine","setTimeout","drawLinesSequentially","ref","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b264296c.chunk.js","sourcesContent":["export default class Vec {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(other: Vec): Vec {\n    return new Vec(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: Vec): Vec {\n    return new Vec(this.x - other.x, this.y - other.y);\n  }\n}\n","import Line from '../geometry/Line';\nimport Vec from '../geometry/Vec';\n\n/**\n * Completely clear the canvas.\n */\nexport function clear(context: CanvasRenderingContext2D): void {\n  context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n}\n\n/**\n * Draw a single line.\n */\nexport function drawLine(line: Line, context: CanvasRenderingContext2D): void {\n  const from = convertCoordinates(line.from, context);\n  const to = convertCoordinates(line.to, context);\n  context.lineWidth = 1;\n  context.beginPath();\n  context.moveTo(from.x, from.y);\n  context.lineTo(to.x, to.y);\n  context.stroke();\n}\n\n/**\n * Convert \"normal\" coordinates into the coordinate system used by the HTML canvas element.\n *\n * \"Normal\" coordinates are how we (I) usually think of a coordainte system:\n * - The origin is in the center\n * - The x axis increases to the right\n * - The y axis increases going up\n *\n * The HTML canvas element uses a different system, where\n * - The origin is in the upper left\n * - The x axis increases to the right (as it does in the \"normal\" one)\n * - The y axis  increases going down.\n */\nexport function convertCoordinates(point: Vec, context: CanvasRenderingContext2D): Vec {\n  return new Vec(\n    point.x + (context.canvas.width / 2),\n    -point.y + (context.canvas.height / 2),\n  );\n}\n","export default class Angle {\n  radians: number;\n\n  static fromDegrees(degrees: number) {\n    return new Angle(degrees * Math.PI / 180);\n  }\n\n  constructor(radians: number) {\n    this.radians = radians;\n  }\n\n  get degrees() {\n    return this.radians * 180 / Math.PI;\n  }\n\n  subtract(other: Angle) {\n    return new Angle(this.radians - other.radians);\n  }\n\n  add(other: Angle) {\n    return new Angle(this.radians + other.radians);\n  }\n}\n","/**\n * L-system drawing instructions.\n */\nexport enum Instruction {\n  DrawLeaf,\n  DrawLine,\n  Noop,\n  PopAngle,\n  PopPosition,\n  PushAngle,\n  PushPosition,\n  TurnLeft,\n  TurnRight,\n}\n","import { Instruction } from './instructions';\nimport { generate, goto } from './l-system';\n\nconst axiom = '0';\nconst rules = {\n  1: '11',\n  0: '1[0]0',\n};\n\n/**\n * Generate drawing instructions for a binary, fractal tree.\n */\nexport default function fractalTree(iterations: number): Instruction[] {\n  const system = generate(axiom, rules);\n  const symbols = goto(system, iterations);\n  console.log('fractal tree symbols:', symbols);\n  return symbols.split('').flatMap(getInstructions);\n}\n\nfunction getInstructions(char: string): Instruction[] {\n  switch (char) {\n    case '0':\n      return [Instruction.DrawLeaf];\n    case '1':\n      return [Instruction.DrawLine];\n    case '[':\n      return [Instruction.PushPosition, Instruction.PushAngle, Instruction.TurnLeft];\n    case ']':\n      return [Instruction.PopPosition, Instruction.PopAngle, Instruction.TurnRight];\n    default:\n      return [Instruction.Noop];\n  }\n}\n","import Vec from './Vec';\n\nexport default class Line {\n  from: Vec;\n  to: Vec;\n\n  constructor(from: Vec, to: Vec) {\n    this.from = from;\n    this.to = to;\n  }\n}\n","import Angle from './Angle';\nimport Vec from './Vec';\n\n/**\n * This \"turtle\" keeps track of its position on an infinite plane through a series of rotations and\n * movements.\n *\n * Unlike the HTML canvas element's coordinate system, the coordinate system here is more\n * \"standarcd\". The x axis increases to the right, and the y axis increases going up.\n *\n *   x\n *   ┃\n *   ┃\n * ↑ ┃\n *   ┃\n * 0 ┗━━━━━━━━━━━ y\n *   0    →\n *\n * As far as angles go, 0 degrees points straight to the right, and 90 degrees straight up.\n */\nexport default class Turtle {\n  angle: Angle;\n  position: Vec;\n\n  constructor(angle: Angle, position: Vec) {\n    this.angle = angle;\n    this.position = position;\n  }\n\n  gotoAngle(angle: Angle): Vec {\n    this.angle = angle;\n    return this.position;\n  }\n\n  gotoPosition(position: Vec): Vec {\n    this.position = position;\n    return position;\n  }\n\n  turnRight(angle: Angle): Vec {\n    this.angle = this.angle.subtract(angle);\n    return this.position;\n  }\n\n  turnLeft(angle: Angle): Vec {\n    this.angle = this.angle.add(angle);\n    return this.position;\n  }\n\n  moveForward(distance: number): Vec {\n    const positionChange = new Vec(\n      Math.cos(this.angle.radians) * distance,\n      Math.sin(this.angle.radians) * distance,\n    );\n    this.position = this.position.add(positionChange);\n    return this.position;\n  }\n}\n","import { useRef, useState } from 'react';\nimport { clear, drawLine } from '../draw/canvas';\nimport Angle from '../geometry/Angle';\nimport Line from '../geometry/Line';\nimport Vec from '../geometry/Vec';\nimport fractalTree from '../system/fractal-tree';\nimport interpret from '../interpreter';\n\nexport default function App() {\n  const [angle, setAngle] = useState(45);\n  const [iterations, setIterations] = useState(7);\n  const [length, setLength] = useState(2);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  function handleClick() {\n    if (canvasRef.current) {\n      const instructions = fractalTree(iterations);\n      const lines = interpret(instructions, {\n        segmentLength: length,\n        startAngle: Angle.fromDegrees(90),\n        startPosition: new Vec(0, -300),\n        turnAngle: Angle.fromDegrees(angle),\n      });\n      const context = canvasRef.current.getContext('2d')!;\n      clear(context);\n      drawLinesSequentially(lines, context);\n    }\n  }\n\n  return (\n    <>\n      <header>\n        <div>\n          <label htmlFor=\"angle\">Angle</label>\n          <input id=\"angle\" type=\"range\" min=\"10\" max=\"60\" value={angle} onChange={(event) => setAngle(Number(event.target.value))} />\n          <span>{angle}</span>\n        </div>\n        <div>\n          <label htmlFor=\"iterations\">Iterations</label>\n          <input id=\"iterations\" type=\"range\" min=\"1\" max=\"20\" value={iterations} onChange={(event) => setIterations(Number(event.target.value))} />\n          <span>{iterations}</span>\n        </div>\n        <div>\n          <label htmlFor=\"length\">Length</label>\n          <input id=\"length\" type=\"range\" min=\"0.1\" max=\"20\" step=\"0.1\" value={length} onChange={(event) => setLength(Number(event.target.value))} />\n          <span>{length}</span>\n        </div>\n        <button onClick={handleClick}>Draw</button>\n      </header>\n      <main>\n        <canvas ref={canvasRef} height=\"600\" width=\"600\" />\n      </main>\n    </>\n  );\n}\n\nfunction drawLinesSequentially(lines: Line[], context: CanvasRenderingContext2D): void {\n  lines.reduce((acc, line) => {\n    return acc.then(() => {\n      return new Promise((resolve) => {\n        drawLine(line, context);\n        setTimeout(() => {\n          resolve();\n        }, 1);\n      });\n    });\n  }, Promise.resolve());\n}\n","import Angle from './geometry/Angle';\nimport Line from './geometry/Line';\nimport Turtle from './geometry/Turtle';\nimport Vec from './geometry/Vec';\nimport { Instruction } from './system/instructions';\n\ninterface Context {\n  segmentLength: number,\n  startAngle: Angle,\n  startPosition: Vec,\n  turnAngle: Angle,\n}\n\n/**\n * Covnert a sequence of instructions into corresponding lines we can draw to a canvas.\n *\n * These lines are in a different coordinate system than the HTML canvas element uses, and will\n * need to be converted before drawing.\n */\nexport default function interpret(systemInstructions: Instruction[], context: Context): Line[] {\n  const output: Line[] = [];\n  const turtle = new Turtle(context.startAngle, context.startPosition);\n  const angleStack: Angle[] = [];\n  const positionStack: Vec[] = [];\n  let currentPosition = context.startPosition;\n\n  // Convert an instruction into one or more lines. This is a state machine, since the instructions\n  // can be statefull.\n  for (let instruction of systemInstructions) {\n    switch (instruction) {\n      case Instruction.DrawLeaf: {\n        const originalAngle = turtle.angle;\n        const leafLength = context.segmentLength / 2;\n\n        // Line 1.\n        turtle.turnLeft(context.turnAngle);\n        const end1 = turtle.moveForward(leafLength);\n        output.push(new Line(currentPosition, end1));\n\n        // Line 2.\n        turtle.gotoAngle(originalAngle);\n        turtle.gotoPosition(currentPosition);\n        const end2 = turtle.moveForward(leafLength);\n        output.push(new Line(currentPosition, end2));\n\n        // Line 3.\n        turtle.gotoAngle(originalAngle);\n        turtle.gotoPosition(currentPosition);\n        turtle.turnRight(context.turnAngle);\n        const end3 = turtle.moveForward(leafLength);\n        output.push(new Line(currentPosition, end3));\n\n        // Restore original location.\n        turtle.gotoAngle(originalAngle);\n        turtle.gotoPosition(currentPosition);\n        break;\n      }\n      case Instruction.DrawLine: {\n        const nextPosition = turtle.moveForward(context.segmentLength);\n        const line = new Line(currentPosition, nextPosition);\n        output.push(line);\n        currentPosition = nextPosition;\n        break;\n      }\n      case Instruction.PopAngle: {\n        const previousAngle = angleStack.pop();\n        if (previousAngle) {\n          turtle.gotoAngle(previousAngle);\n        }\n        break;\n      }\n      case Instruction.PopPosition: {\n        const previousPosition = positionStack.pop();\n        if (previousPosition) {\n          currentPosition = previousPosition;\n          turtle.gotoPosition(previousPosition);\n        }\n        break;\n      }\n      case Instruction.PushAngle:\n        angleStack.push(turtle.angle);\n        break;\n      case Instruction.PushPosition:\n        positionStack.push(turtle.position);\n        break;\n      case Instruction.TurnLeft:\n        turtle.turnLeft(context.turnAngle);\n        break;\n      case Instruction.TurnRight:\n        turtle.turnRight(context.turnAngle);\n        break;\n      default:\n        // Noop\n    }\n  }\n\n  return output;\n}\n","interface Rules {\n  [predecessor: string]: string;\n}\n\n/**\n * Generator that yields successive iterations of an L-system.\n *\n * The `axiom` is the first iteration, and the `rules` translate the symbols of each iteration into\n * the next. Any characters not appearing in the rules will be carried over as-is to the next\n * iteration.\n *\n * @see https://en.wikipedia.org/wiki/L-system\n */\nexport function* generate(axiom: string, rules: Rules): Generator<string> {\n  let current = axiom;\n\n  while (true) {\n    const next = current\n      .split('')\n      .map((char) => rules[char] || char)\n      .join('');\n\n    yield next;\n\n    current = next;\n  }\n}\n\n/**\n * Get the nth value from a generator. Note that generators are stateful, and this does progress\n * the generator to the specified index.\n */\nexport function goto<T>(generator: Generator<T>, index: number): T {\n  let value = generator.next().value;\n\n  for (let i = 1; i <= index; i++) {\n    value = generator.next().value;\n  }\n\n  return value;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}